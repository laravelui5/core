---
author: mgerzabek
title: How LaravelUi5 Makes Self-Describing Software Possible
description: LaravelUi5/Core gives applications a structured way to describe themselves. The Sdk builds on this foundation to deliver a living, context-aware help system that ships with your code. Learn how metadata, modules, and runtime context come together to let software finally speak for itself.
---

# How LaravelUi5 Makes Self-Describing Software Possible

> LaravelUi5/Core gives applications a structured way to describe themselves.  
> The Sdk builds on this foundation to deliver a living, context-aware help system that ships with your code. Learn how metadata, modules, and runtime context come together to let software finally speak for itself.
>
> *From metadata… to a living help system.*

When you read the essay [When Software Learns to Speak], you encounter a simple idea. Software shouldn’t rely on external documentation to explain itself. It should rather be able to speak from within.

This companion article shows how that idea becomes real inside LaravelUi5.
Not through magic or convention, but through architecture: first [Core], then the [Sdk].

Let’s walk through it in the way developers appreciate, from structure, to capability, to experience.

## Why a Meta Layer Belongs in the Architecture

Modern applications already carry an enormous amount of knowledge about themselves:

* which modules exist,
* which features belong to which domain,
* which actions are possible,
* which screens and routes matter,
* which states, roles, or flows define meaning.

Traditionally, none of this knowledge is available to a help system.
It lives in the code, implicitly, and stays inaccessible to anything outside the code.

So teams compensate: wikis, onboarding calls, training slides, scattered documentation.

LaravelUi5 takes a different approach.
It turns the knowledge *inside* the codebase into a structured, explicit layer. A layer that other systems (including Help) can understand and build upon.

That layer begins with [LaravelUi5/Core].

## Giving the Application a Vocabulary

Core is not a help system.
It is the [descriptive foundation] that makes any kind of meta layer possible.

Core gives each module, feature, action, and report:

* a **stable identity**,
* a **clear place in the module tree**,
* and a **declarative description** through typed PHP attributes.

Developers write clean Laravel code.
Core observes, reflects, and gathers the declarations into a single structure: the [Ui5Registry].

You can think of the registry as the application’s self-awareness.
It knows:

* which modules exist,
* which artifacts those modules expose,
* what each artifact is meant to do,
* how features relate,
* which abilities belong to which actions,
* how navigation should behave.

All of this is generated by scanning the code.

Core does not produce help content.
But it exposes the *shape* of the system with enough precision that a help layer can read it.

Core provides the foundation.
The [Sdk] builds the living system on top.

## From Description to Understanding

Once the registry exists, something becomes possible that is normally very difficult.
The system can be understood from within.

If a module declares its screens and actions,
and if these declarations live in a versioned, unified registry,
then the help system doesn’t need to guess.

It can:

* identify where the user is,
* map the UI location to a module,
* discover the relevant concept or feature,
* and select the correct help topic.

This is why the meta layer is not a bolt-on feature in LaravelUi5.
It’s the natural outcome of Core’s reflective design.

In other words…

> **Core doesn’t implement help.
> Core makes help possible.**

The Sdk does the rest.

## Bringing the Meta Layer to Life

The [Sdk] extends Core in the same spirit Laravel extends Symfony.
Quietly, respectfully, without breaking the underlying foundation.

Where Core describes,
the *Sdk operationalizes*.

This includes the entire runtime needed for a living help system.

**Context Resolution**

The Sdk reads the registry and determines where the user is in the application.
It knows the module, the feature, the artifact, the screen, the state.

**Help Service & Adapter**

This small service receives the current context and decides which help topic belongs to it.
If a topic exists at that exact location, it’s selected.
If not, the system climbs the module tree until it finds the right level of abstraction.

**Per-Module Help Trees**

Each module ships its own help content (Markdown files).
Content stays versioned with the module.

**Help Registry**

The Sdk collects all help trees into a single, searchable structure.
This registry mirrors the structure created by Core, just with documentation attached.

**Viewer & Search Overlay**

Help is rendered into a clean HTML viewer,
with deep linking, i18n, and instant search.

**The F1 Workflow**

When the user presses F1, the Sdk resolves context, finds the matching help topic, and opens the viewer.

This is what transforms the conceptual idea of “software that can speak” into a daily experience.

## What This Means for Developers

Because the meta layer grows out of Core, using it requires no special discipline from developers.

* Write your modules cleanly.
* Describe your artifacts using attributes.
* Add help content as Markdown inside the module.
* Run your builds.
* Ship your release.

The Sdk takes the descriptive foundation from Core and turns it into a help system that

* never drifts out of sync,
* travels with your deployments,
* respects version boundaries,
* works across modules,
* and speaks the same language as your code.

Your job is simply to write the truths of your system in one place, the code.
Everything else flows from that.

## A Layer We Forgot to Build

Most applications treat help as content.
LaravelUi5 treats help as architecture.

Core gives the system the ability to describe itself.
The Sdk gives it the ability to speak.

Together, they form the meta layer the industry has overlooked for decades, a layer where understanding finally has a home inside the product, not outside of it.

If you’d like to explore the architectural story behind this idea,
read the companion essay on Pragmatiqu.io:

[When Software Learns to Speak]

And if you want to build systems where explanation is built-in instead of bolted-on,
start with [LaravelUi5/Core] and bring it to life with the [Sdk].

[When Software Learns to Speak]: https://pragmatiqu.io/archive/2025/12/05
[Core]: https://packagist.org/packages/laravelui5/core
[Sdk]: https://pragmatiqu.io/laravelui5/sdk
[LaravelUi5/Core]: https://github.com/laravelui5/core
[descriptive foundation]: https://laravelui5.com/blog/2025/11/21/
[Ui5Registry]: https://laravelui5.com/api/LaravelUi5.Core.Ui5.Contracts.Ui5RegistryInterface.html
